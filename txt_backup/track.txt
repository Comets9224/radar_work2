# File processed on: 2025-06-10 23:33:37

# modules/track.py
import numpy as np
from .kalman_filter import ExtendedKalmanFilter # 确保 kalman_filter.py 在同级
import config as cfg
from . import data_generator # 从同级目录导入 data_generator

class Track:
    _next_id = 1 # 类变量，用于生成独一无二的ID

    def __init__(self, initial_measurement_polar, observer_state_global, current_time, dt):
        """
        初始化一个航迹。
        :param initial_measurement_polar: 用于初始化航迹的第一个雷达观测 [r, theta_local, vr]
        :param observer_state_global: 当时观测者的状态 [px, py, vx, vy]
        :param current_time: 当前时间
        :param dt: 时间步长
        """
        self.track_id = Track._next_id
        Track._next_id += 1

        self.age = 1
        self.time_created = current_time
        self.time_updated = current_time
        self.hits = 1
        self.misses = 0
        self.state = 'Tentative' # 状态: Tentative -> Confirmed -> Deleted
        self.history = []   # 存储历史状态 [px, py, vx, vy]

        # 初始化EKF的状态和协方差
        r, theta_local, vr_local = initial_measurement_polar
        obs_px, obs_py, obs_vx, obs_vy = observer_state_global
        obs_heading = np.arctan2(obs_vy, obs_vx) if not (np.isclose(obs_vx,0) and np.isclose(obs_vy,0)) else 0

        x_radar = r * np.cos(theta_local)
        y_radar = r * np.sin(theta_local)

        x_global_rel = x_radar * np.cos(obs_heading) - y_radar * np.sin(obs_heading)
        y_global_rel = x_radar * np.sin(obs_heading) + y_radar * np.cos(obs_heading)

        px_init = obs_px + x_global_rel
        py_init = obs_py + y_global_rel
        
        # 初始速度估计 (简化为0，让滤波器估计)
        vx_init = 0.0
        vy_init = 0.0
        # 或者，一个更粗略的基于径向速度的估计（如果需要）
        # vx_init = obs_vx + vr_local * np.cos(theta_local + obs_heading)
        # vy_init = obs_vy + vr_local * np.sin(theta_local + obs_heading)


        x_init_vec = np.array([[px_init], [py_init], [vx_init], [vy_init]])

        P_init_diag = [
            cfg.SIGMA_RANGE**2,
            (r * cfg.SIGMA_AZIMUTH)**2 if r > 0.1 else (0.5 * cfg.SIGMA_AZIMUTH)**2, # 避免r过小导致P过小
            10**2, # 初始速度不确定性较大 (m/s)^2
            10**2
        ]
        P_init_mat = np.diag(P_init_diag)

        self.motion_model_type = 'CV' # 默认新航迹为CV模型

        if self.motion_model_type == 'CV':
            # 从 data_generator 模块获取函数
            F_func = lambda d_t: data_generator.get_cv_matrices(d_t)[0]
            Q_func = lambda d_t: data_generator.get_cv_matrices(d_t)[1]
        elif self.motion_model_type == 'CA':
            # 注意: 当前 EKF 实现是针对4维状态的。
            # 如果要真正使用CA模型跟踪，需要一个6维状态的EKF，
            # 或者修改当前EKF以适应不同维度的状态。
            # 目前，即使声明为CA，初始化也将使用CV模型参数。
            print(f"Warning: Track ID {self.track_id} - CA model selected for init, but EKF is 4D. Initializing with CV parameters.")
            x_init_vec_ca = np.array([[px_init], [py_init], [vx_init], [vy_init], [0.0], [0.0]]) # 初始加速度为0
            P_init_diag_ca = P_init_diag + [cfg.q_ca_jerk_noise_std**2 * dt**2, cfg.q_ca_jerk_noise_std**2 * dt**2] # 粗略的加速度初始不确定性
            P_init_mat_ca = np.diag(P_init_diag_ca)
            # F_func_ca = lambda d_t: data_generator.get_ca_matrices(d_t)[0]
            # Q_func_ca = lambda d_t: data_generator.get_ca_matrices(d_t)[1]
            # self.kf = ExtendedKalmanFilter(x_init_vec_ca, P_init_mat_ca, F_func_ca, Q_func_ca, cfg.R_MEASUREMENT, dt) # 需要6D EKF
            F_func = lambda d_t: data_generator.get_cv_matrices(d_t)[0] # 强制用CV初始化
            Q_func = lambda d_t: data_generator.get_cv_matrices(d_t)[1]
        else:
            raise ValueError(f"Unknown motion model for track: {self.motion_model_type}")

        self.kf = ExtendedKalmanFilter(x_init_vec, P_init_mat, F_func, Q_func, cfg.R_MEASUREMENT, dt)
        self.history.append(self.kf.x.flatten().copy()) # 存储初始状态

    def predict(self):
        self.age += 1
        self.kf.predict()
        # 预测后的状态不立即加入history，等待更新或标记为未命中后再加入

    def update(self, measurement_polar, observer_state_global, current_time):
        # measurement_polar 是 [r, theta_local, vr]
        update_successful = self.kf.update(measurement_polar, observer_state_global)
        if update_successful:
            self.hits += 1
            self.misses = 0 # 重置连续未命中次数
            self.time_updated = current_time
            self.history.append(self.kf.x.flatten().copy())
            return True
        else:
            # EKF更新失败（例如S矩阵奇异），也视为一次未命中
            self.mark_missed() # 或者有其他处理逻辑
            return False


    def mark_missed(self):
        self.misses += 1
        # self.hits = 0 # 根据M/N逻辑，有时不重置hits，看具体策略
        # 航迹未得到更新，但其状态已经被预测过了，所以history中记录的是预测状态
        self.history.append(self.kf.x.flatten().copy())


    def get_predicted_measurement(self, observer_state_global):
        """获取当前滤波器状态预测的观测值 [r, theta_local, vr] (相对于雷达)"""
        return self.kf.hx(self.kf.x, observer_state_global).flatten()

    def get_state_for_matching(self):
        """返回用于数据关联的预测状态的全局位置 [px, py]"""
        return self.kf.x[:2, 0].flatten()

    def get_current_estimate_global_cartesian(self):
        """返回当前航迹的最佳状态估计 [px, py, vx, vy] (全局坐标)"""
        return self.kf.x.flatten()
